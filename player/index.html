<html>
  <head>
    <title>Phone Party</title>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' />
    <meta name="theme-color" content="#000">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="push-buttons.css">
    <link rel="stylesheet" href="/host/splashScreen.css">
    <link rel="stylesheet" href="movement.css">
    <link rel="stylesheet" href="messaging.css">
    <link rel="stylesheet" href="/games/all-the-things/player/allTheThings.css">
    <link rel="stylesheet" href="/games/all-the-things/player/photoTakingScreen.css">
    <link rel="stylesheet" href="/games/all-the-things/player/photoJudgementScreen.css">
  </head>
  <body>
    <div id="panels">
      <div class="panel" id="subject-panel"></div>
      <div class="panel" id="messaging-panel"></div>
    </div>
    <button id="fullscreen-button" class="unimplemented"></button>
    <div id="status-container" class="waiting">
      <div class="phone-party-logo">
        <div class="phone-party-text"></div>
        <div class="bubbles">
          <span></span>
          <span></span>
          <span></span>
          <span></span>
        </div>
      </div>
      <div class="separator"></div>
      <div id="status"></div>
      <div id="status-detail"></div>
    </div>
  </body>
  <script src="utils.js"></script>
  <script src="audio.js"></script>
  <script src="handleRtcConnection.js"></script>
  <script src="push-buttons.js"></script>
  <script src="splashScreen.js"></script>
  <script src="movement.js"></script>
  <script src="messaging.js"></script>
  <script src="/games/all-the-things/player/allTheThings.js"></script>
  <script src="/games/all-the-things/player/photoTakingScreen.js"></script>
  <script src="/games/all-the-things/player/photoJudgementScreen.js"></script>
  <script>
    "use strict";

    // HTTPS redirect
    if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
      location.href = 'https:' + window.location.href.substring(window.location.protocol.length);
    }

    const statusContainer = document.getElementById('status-container');
    const status          = document.getElementById('status');
    const statusDetail    = document.getElementById('status-detail');

    let stream = null;

    (async function() {

      // Setup video
      while (!stream) {
        statusContainer.className = 'waiting';
        status.textContent = 'Accessing camera..';
        statusDetail.textContent = '';
        try {
          stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});
        } catch(error) {
          if (location.hostname === 'localhost') {
            break;
          }
          statusContainer.className = 'error';
          if (error && error.name === 'NotFoundError') {
            status.textContent = 'no camera found';
          } else {
            status.textContent = 'Could not get camera';
          }
          const retryButton = document.createElement('button');
          retryButton.className = 'push-button';
          retryButton.textContent = 'retry';
          statusDetail.appendChild(retryButton);
          await new Promise(resolve => retryButton.onclick = resolve);
          retryButton.remove();
          break;
        }
      }

      // Setup fullscreen button
      const fullscreenButton = document.getElementById('fullscreen-button');
      if (document.documentElement.requestFullscreen) {
        const clickSound = new Audio('/sounds/click.mp3');
        function toggleFullscreen() {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().then(() => {
              fullscreenButton.classList.add('fullscreen');
            });
          } else {
            document.exitFullscreen().then(() => {
              fullscreenButton.classList.remove('fullscreen');
            });
          }
          clickSound.play();
        }
        fullscreenButton.onclick = toggleFullscreen;
        const touches = new Set();
        fullscreenButton.ontouchstart = event => {
          fullscreenButton.classList.add('active');
          for (const touch of event.changedTouches) {
            touches.add(touch.identifier);
          }
        }
        function onTouchEndOrCancel(event) {
          for (const touch of event.changedTouches) {
            touches.delete(touch.identifier);
            if (touches.size === 0) {
              fullscreenButton.classList.remove('active');
            }
          }
        }
        window.addEventListener('touchend',    onTouchEndOrCancel);
        window.addEventListener('touchcancel', onTouchEndOrCancel);
        fullscreenButton.classList.remove('unimplemented');
      }

      while (true) {
        await waitForPageToBeVisible();
        statusContainer.className = 'waiting';
        status.textContent = 'Connecting..';
        statusDetail.textContent = 'Opening websocket';

        const websocket = new WebSocket(`${location.protocol === 'https:' ? 'wss' : 'ws'}://${location.hostname}:${location.port}/player/ws`);

        let hasHost = false;
        websocket.addEventListener('message', event => {
          const message = JSON.parse(event.data);
          if (message.type === 'host') {
            hasHost = message.message === 'connected';
          }
        });
        websocket.addEventListener('close', event => hasHost = false);
        websocket.addEventListener('error', event => hasHost = false);

        try {
          await waitForWebsocketToConnect(websocket);
        } catch(error) {
          statusContainer.className = 'error';
          status.textContent = 'failed to connect';
          statusDetail.textContent = 'Could not establish websocket, retrying in 2 seconds..';
          await waitForNSeconds(2);
          continue;
        }

        while (true) {
          await waitForPageToBeVisible();

          try {
            if (!hasHost) {
              statusContainer.className = 'waiting';
              status.textContent = 'Waiting for host...';
              statusDetail.textContent = '';
              await waitForHost(websocket);
            }

            statusContainer.className = 'waiting';
            status.textContent = 'Connecting..';
            statusDetail.textContent = 'Establishing WebRTC connection';

            var rtcConnection = new RTCPeerConnection();
            if (stream) {
              stream.getTracks().forEach(track => rtcConnection.addTrack(track, stream));
            }
            let hasSentSdp = false;
            const iceCandidatesToSend = [];
            rtcConnection.addEventListener('icecandidate', event => {
              if (event.candidate) {
                iceCandidatesToSend.push(JSON.stringify(event.candidate.toJSON()));
                if (websocket.readyState === websocket.OPEN && hasSentSdp) {
                  while (iceCandidatesToSend.length) websocket.send(JSON.stringify({type: 'ice', iceCandidate: iceCandidatesToSend.pop()}));
                }
              }
            });
            // TODO: handle rtcConnection.onicecandidateerror

            var channels = {
              accelerometer:    rtcConnection.createDataChannel('accelerometer',   {negotiated: true, id: 3, ordered: false, maxRetransmits: 0}),
              visibility:       rtcConnection.createDataChannel('visibility',      {negotiated: true, id: 5, ordered: true}),
              hostInteraction:  rtcConnection.createDataChannel('hostInteraction', {negotiated: true, id: 6, ordered: true}),
              close:            rtcConnection.createDataChannel('close',           {negotiated: true, id: 7, ordered: true}),
              acceptPlayer:     rtcConnection.createDataChannel('acceptPlayer',    {negotiated: true, id: 8, ordered: true}),
            }

            var waitToBeAccepted = new Promise(resolve => {
              channels.acceptPlayer.onmessage = resolve;
            });

            try {
              var rtcOffer = await rtcConnection.createOffer();
            } catch(error) {
              statusContainer.className = 'error';
              status.textContent = 'Could not connect';
              statusDetail.textContent = 'WebRTC offer creation failed';
              return;
            }

            rtcConnection.setLocalDescription(rtcOffer);
            websocket.send(JSON.stringify({type: 'sdp', sdp: rtcOffer.sdp}));
            hasSentSdp = true;

            while (iceCandidatesToSend.length) websocket.send(JSON.stringify({type: 'ice', iceCandidate: iceCandidatesToSend.pop()}));

            websocket.addEventListener('message', function callback(event) {
              const message = JSON.parse(event.data);
              if (message.type === 'sdp') {
                rtcConnection.setRemoteDescription({type: 'answer', sdp: message.message});
              } else if (message.type === 'ice') {
                rtcConnection.addIceCandidate(JSON.parse(message.message));
              } else if (message.type === 'host' && message.message === 'disconnected') {
                websocket.removeEventListener('message', callback);
                rtcConnection.close();
              }
            });

            try {
              var result = await Promise.race([waitForRtcConnection(rtcConnection), waitForWebsocketToDisconnect(websocket)]);
            } catch(error) {
              if (error === 'rtc_disconnected') {
                statusContainer.className = 'error';
                status.textContent = 'Could not connect';
                statusDetail.textContent = 'WebRTC disconnected. Retrying in 2 seconds..';
                await waitForNSeconds(2);
                continue;
              } else {
                throw error;
              }
            }
            if (result === 'websocket_disconnected') {
              throw 'websocket disconnected before RTC connection could be established';
            }
          } catch(error) {
            if (websocket.readyState === websocket.CLOSING || websocket.readyState === websocket.CLOSED) {
              rtcConnection.close();
              statusContainer.className = 'error';
              status.textContent = 'Could not connect';
              statusDetail.textContent = 'Websocket disconnected, reconnecting in 2 seconds..';
              await waitForNSeconds(2);
              break;
            } else {
              throw error;
            }
          }

          handleRtcConnection(rtcConnection, channels);

          statusContainer.className = 'waiting';
          status.textContent = 'Waiting to be accepted';
          statusDetail.textContent = '';
          await waitToBeAccepted;

          statusContainer.className = '';
          status.textContent = '';
          statusDetail.textContent = '';

          window.onunload = window.onbeforeunload = () => {
            if (channels.close.readyState === 'open') {
              channels.close.send('true');
            }
          }

          const waitForCloseChannel = new Promise(resolve => channels.close.onmessage = () => resolve('close_channel'));

          var result = await Promise.race([waitForRtcToDisconnect(rtcConnection), waitForCloseChannel]);
          if (result === 'close_channel') {
            rtcConnection.close();
            hasHost = false;
            statusContainer.className = 'error';
            status.textContent = 'Host disconnected';
            statusDetail.textContent = '';
            await waitForNSeconds(2);
            continue;
          } else {
            statusContainer.className = 'error';
            status.textContent = 'Disconnected';
            status.textContent = 'WebRTC disconnected, reconnecting in 5 seconds..';
            await waitForNSeconds(5);
            continue;
          }
        }
      }
    })();
  </script>
</html>
