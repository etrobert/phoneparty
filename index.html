<html>
  <head>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' />
  </head>
  <body>
    <video id="video" playsinline autoplay muted></video>
    <div id="buttons">
      <div id="arrow-buttons">
        <button data-button="up"    class="arrow-button" data-key="ArrowUp">   </button>
        <button data-button="down"  class="arrow-button" data-key="ArrowDown"> </button>
        <button data-button="left"  class="arrow-button" data-key="ArrowLeft"> </button>
        <button data-button="right" class="arrow-button" data-key="ArrowRight"></button>
      </div>
      <button data-button="ping" data-key=" "></button>
    </div>
    <button id="fullscreen-button"></button>
    <div id="connection_status" class="connecting"></div>
  </body>
  <style>
    body {
      margin: 0;
    }
    body.chosen:before {
      content: '';
      position: fixed;
      width:  100%;
      height: 100%;
      background-color: blue;
      opacity: 0.8;
      z-index: 2;
    }
    body.chosen:after {
      content: '';
      position: fixed;
      z-index: 3;
      left: 50%;
      top:   -15vmin;
      width:  70vmin;
      height: 70vmin;
      margin-left: -35vmin;
      background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDEgMSIgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIj48cGF0aCBkPSJNIDAsMC44IDAuNSwwLjIgMSwwLjggeiIgc3R5bGU9ImZpbGw6I2ZmZmZmZjtzdHJva2U6bm9uZTsiIC8+PC9zdmc+');
      background-repeat: no-repeat;
      background-size: 100%;
      transform: rotate(180deg);
      pointer-events: none;
    }
    body.chosen.chosen-final:before { animation: 0.3s steps(2) flash 5; }
    body.chosen.chosen-final:after  { animation: 0.3s steps(2) flash 5; }
    @keyframes flash {
      from { opacity: 1; }
      to   { opacity: 0; }
    }
    #video {
      position: fixed;
      width:  100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
    }
    #connection_status {
      position: fixed;
      width:  100%;
      height: 100%;
      display: none;
      flex-direction: column;
      background-color: #fff;
      text-align:      center;
      justify-content: center;
      align-items:     center;
      font-size: 5vw;
    }
    #connection_status.connecting { display: flex; background-color: blue; }
    #connection_status.error      { display: flex; background-color: red;  }
    #connection_status::before {
      font-size: 10vw;
    }
    #connection_status.connecting::before { content: 'Connecting..'; }
    #connection_status.error::before      { content: 'Error';        }
    button {
      font-size: 15vw;
      background-color: grey;
      border-radius: 10vw;
      border: 1vw solid white;
      opacity: 0.8;
      outline: none;
      cursor: pointer;
    }
    button:hover {
      background-color: #b3b3b3;
    }
    button:after {
      background-repeat: no-repeat;
      background-position: center;
      background-size: 70%;
    }
    button.pressed {
      transform: scale(1.4);
      background-color: orange;
    }
    .arrow-button:after {
      content: '';
      position: absolute;
      left: 0;
      top:  0;
      width:  100%;
      height: 100%;
      background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDEgMSIgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIj48cGF0aCBkPSJNIDAsMC44IDAuNSwwLjIgMSwwLjggeiIgc3R5bGU9ImZpbGw6IzAwMDAwMDtzdHJva2U6bm9uZTsiIC8+PC9zdmc+');
    }
    #buttons {
      display: flex;
      flex-direction: column;
      align-items: center;
      position: fixed;
      left:  0;
      top:   0;
      right: 0;
      max-height: 100vh;
    }
    button[data-button="down"]:after  { transform: rotate(180deg); }
    button[data-button="left"]:after  { transform: rotate(-90deg); }
    button[data-button="right"]:after { transform: rotate(90deg);  }
    #arrow-buttons {
      position: relative;
      flex-shrink: 1;
      flex-grow: 0;
      flex-basis: 90vw;
      width:      90vw;
      max-width: calc(100vh - 42vw);
    }
    #arrow-buttons button {
      position: absolute;
      width:  30%;
      height: 30%;
      border-radius: 100%;
    }
    #arrow-buttons [data-button="up"]    { left:  50%; top:     0;  margin-left: -15%; }
    #arrow-buttons [data-button="down"]  { left:  50%; bottom:  0;  margin-left: -15%; }
    #arrow-buttons [data-button="left"]  { left:   0;  top:    50%; margin-top:  -15%; }
    #arrow-buttons [data-button="right"] { right:  0;  top:    50%; margin-top:  -15%; }
    button[data-button="ping"] {
      flex-shrink: 0;
      flex-grow:   0;
      width:  80vw;
      height: 30vw;
      margin-top:    8vw;
      margin-bottom: 8vw;
      position: relative;
    }
    @media (orientation: landscape) {
      #buttons {
        flex-direction: row;
        align-items: center;
        bottom: 0;
      }
      #arrow-buttons {
        flex-grow: 0;
        height:     90vh;
        flex-basis: 90vh;
        max-width: none;
        margin-left:  calc(((100vw - 46vh) - 90vh) * 0.2);
        margin-right: calc(((100vw - 46vh) - 90vh) * 0.8);
      }
      button[data-button="ping"] {
        height: 80vh;
        width:  30vh;
        margin-left:   4vh;
        margin-right: 12vh;
      }
    }
    button[data-button="ping"]:after {
      content: '';
      left: 0;
      top:  0;
      width:  100%;
      height: 100%;
      position: absolute;
      background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA4LjQ2NyA0LjIzMyIgaGVpZ2h0PSIxNiIgd2lkdGg9IjMyIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIC0yOTIuNzY3KSI+PGNpcmNsZSByPSIuOTI2IiBjeT0iMjk0Ljk2IiBjeD0iNC4yMDYiIHN0eWxlPSJtYXJrZXI6bm9uZSIvPjxwYXRoIGQ9Ik0zLjEyMyAyOTUuOTM0YTEuNDU3IDEuNDU3IDAgMCAxLS4wNDItMS45TTIuMzQgMjk2LjMxNmEyLjMwOCAyLjMwOCAwIDAgMSAuMDM0LTIuNzU5TTEuNjM1IDI5Ni43MTFhMy4xMSAzLjExIDAgMCAxIC4wMzctMy41NTVNNS4yODIgMjk1LjkzNGExLjQ1NyAxLjQ1NyAwIDAgMCAuMDQzLTEuOU02LjA2NiAyOTYuMzE2YTIuMzA4IDIuMzA4IDAgMCAwLS4wMzUtMi43NTlNNi43NyAyOTYuNzExYTMuMTEgMy4xMSAwIDAgMC0uMDM3LTMuNTU1IiBzdHlsZT0ibWFya2VyOm5vbmUiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIuNDQxIi8+PC9nPjwvc3ZnPg==');
    }
    #fullscreen-button {
      background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA4LjQ2NyA4LjQ2NyIgaGVpZ2h0PSIzMiIgd2lkdGg9IjMyIj48ZyBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iLjc5NCI+PHBhdGggZD0iTTIuNzE3LjA4djIuODM1SC4wN001Ljc0OC4wOHYyLjgzNWgyLjY0NU0yLjcxNyA4LjQ1M1Y1LjYxOEguMDdNNS43NDggOC40NTNWNS42MThoMi42NDUiLz48L2c+PC9zdmc+');
      background-repeat: no-repeat;
      background-size: 100%;
      border: none;
      position: fixed;
      right: 0;
      top:   0;
      width:  10vmin;
      height: 10vmin;
      border-radius: 0;
    }
  </style>
  <script>
    "use strict";

    // HTTPS redirect
    if (location.hostname !== 'localhost' && !location.hostname.startsWith('192.168.') && location.protocol != 'https:') {
      location.href = 'https:' + window.location.href.substring(window.location.protocol.length);
    }

    const connectionStatus = document.getElementById('connection_status');

    var pokeSound = new Audio("data:audio/wav;base64,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qJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7FtErm5MXMlmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgDGCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgbbJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEEECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/Xx4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+LkhyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///qpoiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQRCSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRobBAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4FFRQWR+LsS4W/rFRb/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU=");
    
    (async function() {
    
      // Setup video
      var stream = null;
      try {
        var stream = await navigator.mediaDevices.getUserMedia({audio: false, video: true});
      } catch(error) {
        if (location.hostname !== 'localhost') {
          connectionStatus.className = 'error';
          if (error && error.name === 'NotFoundError') {
            connectionStatus.textContent = 'No camera found';
          } else {
            connectionStatus.textContent = 'Could not get camera';
          }
          return;
        }
      }

      if (document.body.requestFullscreen) {
        function toggleFullscreen() {
          if (!document.fullscreenElement) {
            document.body.requestFullscreen();
          } else {
            document.exitFullscreen();
          }
        }
        document.getElementById('fullscreen-button').addEventListener('click', toggleFullscreen);
        document.getElementById('fullscreen-button').addEventListener('touchstart', event => {
          event.preventDefault();
          toggleFullscreen();
          return false;
        });
      } else {
        document.getElementById('fullscreen-button').remove();
      }
      
      while (true) {
        await waitForPageToBeVisible();
        connectionStatus.className = 'connecting';
        connectionStatus.textContent = '(websocket)';

        const websocket = new WebSocket(`${location.protocol === 'https:' ? 'wss' : 'ws'}://${location.hostname}:${location.port}/client`);
        
        try {
          await waitForWebsocketToConnect(websocket);
        } catch(error) {
          connectionStatus.className = 'error';
          connectionStatus.textContent = 'Could not establish websocket, retrying in 2 seconds..';
          await waitForNSeconds(2);
          continue;
        }

        connectionStatus.className = 'connecting';
        connectionStatus.textContent = '(waiting for host..)';
        await waitForHost(websocket);

        while (true) {
          await waitForPageToBeVisible();
          connectionStatus.className = 'connecting';
          connectionStatus.textContent = '(WebRTC)';

          const rtcConnection = new RTCPeerConnection();
          if (stream) {
            stream.getTracks().forEach(track => rtcConnection.addTrack(track, stream));
          }
          let hasSentSdp = false;
          const iceCandidatesToSend = [];
          rtcConnection.addEventListener('icecandidate', event => {
            if (event.candidate) {
              iceCandidatesToSend.push(JSON.stringify({candidate: event.candidate.candidate, sdpMid: event.candidate.sdpMid, sdpMLineIndex: event.candidate.sdpMLineIndex}));
              if (websocket.readyState === websocket.OPEN && hasSentSdp) {
                while (iceCandidatesToSend.length) websocket.send(JSON.stringify({iceCandidate: iceCandidatesToSend.pop()}));
              }
            }
          });

          const buttonsChannel = rtcConnection.createDataChannel('buttons', {negotiated: true, id: 1, ordered: true});
          buttonsChannel.onopen = () => {
            for (const button of document.getElementById('buttons').getElementsByTagName('button')) {
              button.ontouchstart = event => {
                event.preventDefault();
                if (!button.classList.contains('pressed')) {
                  button.classList.add('pressed');
                  buttonsChannel.send(button.dataset.button + ' true');
                  function handleTouchend(event) {
                    if (![...event.touches].some(touch => touch.target === button)) {
                      button.classList.remove('pressed');
                      if (buttonsChannel.readyState === 'open') {
                        buttonsChannel.send(button.dataset.button + ' false');
                      }
                      window.removeEventListener('touchend',    handleTouchend);
                      window.removeEventListener('touchcancel', handleTouchend);
                    }
                  }
                  window.addEventListener('touchend',    handleTouchend);
                  window.addEventListener('touchcancel', handleTouchend);
                }
                return false;
              }
            }
            for (const button of document.getElementById('buttons').getElementsByTagName('button')) {
              button.onmousedown = event => {
                button.classList.add('pressed');
                buttonsChannel.send(button.dataset.button + ' true');
                window.addEventListener('mouseup', event => {
                  button.classList.remove('pressed');
                  if (buttonsChannel.readyState === 'open') {
                    buttonsChannel.send(button.dataset.button + ' false');
                  }
                }, {once: true});
              }
            }
            function handleKeydown(event) {
              const button = document.querySelector(`button[data-key="${event.key}"]`);
              if (button) {
                event.preventDefault();
                button.classList.add('pressed');
                buttonsChannel.send(button.dataset.button + ' true');
                return false;
              }
            }
            function handleKeyup(event) {
              const button = document.querySelector(`button[data-key="${event.key}"]`);
              if (button) {
                button.classList.remove('pressed');
                buttonsChannel.send(button.dataset.button + ' false');
              }
            }
            window.addEventListener('keydown', handleKeydown);
            window.addEventListener('keyup',   handleKeyup);
            buttonsChannel.onclose = event => {
              window.removeEventListener('keydown', handleKeydown);
              window.removeEventListener('keyup',   handleKeyup);
              for (const button of document.getElementById('buttons').getElementsByTagName('button')) {
                button.onmousedown  = null;
                button.ontouchstart = null;
                button.classList.remove('pressed');
              }
            }
          }

          const wheelChannel = rtcConnection.createDataChannel('wheel', {negotiated: true, id: 2, ordered: true});
          wheelChannel.onmessage = event => {
            document.body.classList.toggle('chosen',       event.data.startsWith('chosen'));
            document.body.classList.toggle('chosen-final', event.data.endsWith('final'));
            if (event.data.startsWith('chosen')) {
              pokeSound.play();
              if (navigator.vibrate) {
                try { navigator.vibrate(200); } catch(error) { }
              }
            }
          }
          wheelChannel.onclose = () => {
            document.body.classList.remove('chosen');
            document.body.classList.remove('chosen-final');
          }

          const accelerometerChannel = rtcConnection.createDataChannel('accelerometer', {negotiated: true, id: 3, ordered: false, maxRetransmits: 0});
          function handleDeviceMotion(event) { accelerometerChannel.send(JSON.stringify({x: event.acceleration.x, y: event.acceleration.y})); }
          accelerometerChannel.onopen  = () => window.addEventListener(   'devicemotion', handleDeviceMotion);
          accelerometerChannel.onclose = () => window.removeEventListener('devicemotion', handleDeviceMotion);

//           const gyroChannel = rtcConnection.createDataChannel('gyro', {negotiated: true, id: 4, ordered: false, maxRetransmits: 0});
//           function handleDeviceOrientation(event) { gyroChannel.send(JSON.stringify({alpha: event.alpha, beta: event.beta, gamma: event.gamma})); }
//           gyroChannel.onopen  = () => window.addEventListener(   'deviceorientation', handleDeviceOrientation);
//           gyroChannel.onclose = () => window.removeEventListener('deviceorientation', handleDeviceOrientation);

          const visibilityChannel = rtcConnection.createDataChannel('visibility', {negotiated: true, id: 5, ordered: true});
          function handleVisibilityChange() { visibilityChannel.send(document.visibilityState); }
          visibilityChannel.onopen  = () => document.addEventListener(   'visibilitychange', handleVisibilityChange);
          visibilityChannel.onclose = () => document.removeEventListener('visibilitychange', handleVisibilityChange);

          // Wait for both the websocket to connect and for the RTC offer to be created
          try {
            var rtcOffer = await rtcConnection.createOffer({offerToReceiveAudio: 1, offerToReceiveVideo: 1})
          } catch(error) {
            connectionStatus.className = 'error';
            connectionStatus.textContent = 'Could not create WebRTC offer';
            return;
          }

          rtcConnection.setLocalDescription(rtcOffer);
          try {
            websocket.send(JSON.stringify({sdp: rtcOffer.sdp}));
          } catch(error) {
            connectionStatus.className = 'error';
            connectionStatus.textContent = 'Websocket disconnected, retrying in 2 seconds..';
            await waitForNSeconds(2);
            continue;
          }
          hasSentSdp = true;

          while (iceCandidatesToSend.length) websocket.send(JSON.stringify({iceCandidate: iceCandidatesToSend.pop()}));

          try {
            var remoteSdp = await waitForMessageFromWebsocket(websocket);
          } catch(error) {
            connectionStatus.className = 'error';
            connectionStatus.textContent = 'Websocket disconnected, reconnecting in 2 seconds..';
            await waitForNSeconds(2);
            break;
          }
          rtcConnection.setRemoteDescription({type: 'answer', sdp: remoteSdp});

          websocket.addEventListener('message', function callback(event) {
            if (event.data === 'Host disconnected') {
              websocket.removeEventListener('message', callback);
            } else {
              rtcConnection.addIceCandidate(JSON.parse(event.data));
            }
          });

          try {
            await Promise.race([waitForRtcConnection(rtcConnection), waitForWebsocketToConnect(websocket)])
          } catch(error) {
            if (error === 'WebsocketError') {
              connectionStatus.className = 'error';
              connectionStatus.textContent = 'Websocket disconnected, reconnecting in 2 seconds..';
              await waitForNSeconds(2);
              break;
            } else {
              connectionStatus.className = 'error';
              connectionStatus.textContent = 'Could not establish WebRTC connection, retrying in 2 seconds..';
              await waitForNSeconds(2);
              continue;
            }
          }
          
          connectionStatus.className = 'connected';
          connectionStatus.textContent = '';
          const video = document.getElementById('video');
          video.srcObject = stream;

          try {
            var result = await Promise.race([waitForRtcToDisconnect(rtcConnection), waitForHostDisconnect(websocket)]);
          } catch(error) {
            if (error === 'websocket_disconnected') {
              connectionStatus.className = 'error';
              connectionStatus.textContent = 'Websocket disconnected, reconnecting in 2 seconds..';
              await waitForNSeconds(2);
              break;
            }
          }
          if (result === 'webrtc_disconnected') {
            connectionStatus.className = 'error';
            connectionStatus.textContent = 'WebRTC Disconnected, reconnecting in 2 seconds..';
            await waitForNSeconds(2);
            continue;
          } else if (result === 'host_disconnected') {
            rtcConnection.close();
            connectionStatus.className = 'error';
            connectionStatus.textContent = 'Host Disconnected, waiting for new host..';
            try {
              await waitForHost(websocket);
            } catch(error) {
              if (error === 'websocket_disconnected') {
                break;
              }
            }
            continue;
          }
        }
      }
    })();

    function waitForWebsocketToConnect(websocket) {
      return new Promise((resolve, reject) => {
        if (websocket.readyState === websocket.OPEN) {
          resolve();
        } else if (websocket.readyState === websocket.CLOSING || websocket.readyState === websocket.CLOSED) {
          reject();
        } else {
          websocket.addEventListener('open',  event => resolve(event),           {once: true});
          websocket.addEventListener('close', event => reject('WebsocketError'), {once: true});
          websocket.addEventListener('error', event => reject('WebsocketError'), {once: true});
        }
      });
    }

    function waitForMessageFromWebsocket(websocket) {
      return new Promise((resolve, reject) => {
        websocket.addEventListener('message', event => { resolve(event.data); }, {once: true});
        websocket.addEventListener('close',   event => { reject(event); },       {once: true});
        websocket.addEventListener('error',   event => { reject(event); },       {once: true});
      });
    }

    function waitForHost(websocket) {
      return new Promise((resolve, reject) => {
        function callback(event) {
          if (event.data === 'Host connected') {
            resolve('host_connected');
            websocket.removeEventListener('message', callback);
          }
        }
        websocket.addEventListener('message', callback);
        websocket.addEventListener('close',   event => { reject('websocket_disconnected'); websocket.removeEventListener('message', callback) }, {once: true});
        websocket.addEventListener('error',   event => { reject('websocket_disconnected'); websocket.removeEventListener('message', callback) }, {once: true});
      });
    }

    function waitForHostDisconnect(websocket) {
      return new Promise((resolve, reject) => {
        function callback(event) {
          if (event.data === 'Host disconnected') {
            resolve('host_disconnected');
            websocket.removeEventListener('message', callback);
          }
        }
        websocket.addEventListener('message', callback);
        websocket.addEventListener('close',   event => { reject('websocket_disconnected'); websocket.removeEventListener('message', callback) }, {once: true});
        websocket.addEventListener('error',   event => { reject('websocket_disconnected'); websocket.removeEventListener('message', callback) }, {once: true});
      });
    }

    function waitForRtcConnection(rtcConnection) {
      return new Promise((resolve, reject) => {
        if (rtcConnection.iceConnectionState in {connected: true, completed: true}) {
          resolve();
        } else if (rtcConnection.iceConnectionState in {disconnected: true, failed: true, closed: true}) {
          reject();
        } else {
          rtcConnection.addEventListener('iceconnectionstatechange', function callback(event) {
            if (rtcConnection.iceConnectionState in {connected: true, completed: true}) {
              resolve();
              rtcConnection.removeEventListener('iceconnectionstatechange', callback);
            } else if (rtcConnection.iceConnectionState in {disconnected: true, failed: true, closed: true}) {
              reject();
              rtcConnection.removeEventListener('iceconnectionstatechange', callback);
            }
          });
        }
      });
    }

    function waitForRtcToDisconnect(rtcConnection) {
      return new Promise((resolve, reject) => {
        if (rtcConnection.iceConnectionState in {disconnected: true, failed: true, closed: true}) {
          resolve('webrtc_disconnected');
        } else {
          rtcConnection.addEventListener('iceconnectionstatechange', function callback(event) {
            if (rtcConnection.iceConnectionState in {disconnected: true, failed: true, closed: true}) {
              resolve('webrtc_disconnected');
              rtcConnection.removeEventListener('iceconnectionstatechange', callback);
            }
          });
        }
      });
    }

    function waitForNSeconds(seconds) {
      return new Promise(resolve => { setTimeout(resolve, 1000 * seconds); });
    }

    function waitForPageToBeVisible() {
      return new Promise(resolve => {
        if (document.visibilityState === 'visible') {
          resolve();
        } else {
          document.addEventListener('visibilitychange', function callback(event) {
            if (document.visibilityState === 'visible') {
              resolve();
              document.removeEventListener('visibilitychange', callback);
            }
          });
        }
      });
    }
  </script>
</html>
